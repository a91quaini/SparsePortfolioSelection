% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{calibrate_factor_model}
\alias{calibrate_factor_model}
\title{Calibrate a Factor Model}
\usage{
calibrate_factor_model(
  returns,
  factors,
  weak_coeff = 0,
  idiosy_vol_type = 0,
  do_checks = FALSE
)
}
\arguments{
\item{returns}{A numeric matrix (T x N) of asset returns.}

\item{factors}{A numeric matrix (T x K) of factor returns.}

\item{weak_coeff}{A numeric scalar between 0 and 1 indicating the weakness of the factors.
A value of 0 (default) implies no weakness adjustment,
while a value of 1 implies full adjustment.}

\item{idiosy_vol_type}{A numeric scalar representing the type of idiosyncratic volatility:
0 (default) for homoskedastic; 1 for heteroskedastic.}

\item{do_checks}{Logical flag indicating whether to perform input validation (default is FALSE).}
}
\value{
A list with two components:
\describe{
\item{\eqn{\mu}}{The model-implied mean return vector (an N x 1 matrix or a vector).}
\item{\eqn{\Sigma}}{The model-implied covariance matrix of asset returns (an N x N matrix).}
}
}
\description{
This function calibrates a factor model given a TxN matrix of asset returns and a TxK matrix of factor returns.
The function computes the population mean vector
and covariance matrix of the factors, and uses these to compute regression coefficients via
\eqn{\beta = (\Sigma_f)^{-1} \, \mathrm{Cov}(factors, returns)^T,}
where \eqn{\Sigma_f} is the covariance matrix of the factors.
The model-implied mean return vector is computed as
\eqn{\mu = \beta \, \mu_f,}
where \eqn{\mu_f} is the mean vector of the factors.
Residuals are then computed (from demeaned returns) and their variances are
used to form a diagonal matrix \eqn{\Sigma_0}.
Finally, the covariance matrix of asset returns is estimated as
\eqn{\Sigma = \beta \, \Sigma_f \, \beta^T + \Sigma_0.}
}
\details{
The additional parameter \code{weak_coeff} adjusts the factor betas weakness by dividing them by
\eqn{N^{(\text{weak\_coeff}/2)}}, where \eqn{N} is the number of assets.
A value of \code{0} (default) indicates no adjustment,
while a value of \code{1} indicates full weakness.

The parameter \code{idiosy_vol_type} determines the structure of the idiosyncratic volatility:
\itemize{
\item \code{0} (default): homoskedastic volatility, so \eqn{\Sigma_0} is the average residual variance times the identity.
\item \code{1}: heteroskedastic volatility (no correlation), so \eqn{\Sigma_0} is a diagonal matrix of asset-specific residual variances.
}
}
\examples{
\dontrun{
  set.seed(123)
  T <- 100  # number of time periods
  N <- 5    # number of assets
  K <- 3    # number of factors

  # Create a TxK matrix of factor returns
  factors <- matrix(rnorm(T * K), nrow = T, ncol = K)

  # Create a TxN matrix of asset returns from a linear factor model plus noise
  beta_true <- matrix(runif(N * K), nrow = N, ncol = K)
  returns <- factors \%*\% t(beta_true) + matrix(rnorm(T * N, sd = 0.5), nrow = T, ncol = N)

  # Calibrate the model with no weak factor adjustment (weak_coeff = 0)
  # under homoskedastic volatility
  model1 <- calibrate_factor_model(returns,
                                   factors,
                                   weak_coeff = 0,
                                   idiosy_vol_type = 0,
                                   do_checks = TRUE)

  # Calibrate the model with moderate weak factor adjustment (weak_coeff = 0.5)
  # under heteroskedastic volatility
  model2 <- calibrate_factor_model(returns,
                                   factors,
                                   weak_coeff = 0.5,
                                   idiosy_vol_type = 1,
                                   do_checks = TRUE)

  # Display the calibrated mean return vectors and covariance matrices
  print(model1$mu)
  print(model1$sigma)
  print(model2$mu)
  print(model2$sigma)
}

}
